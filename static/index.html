<!doctype html>
<html>
<head>
<style>

h1{
	height:10%;
}

.section {
	width:100%;
	height:40%;
}

div#memory {
	width:50%;
	height:100%;
	float:left;
}
div#load_avg {
	width:50%;
	height:100%;
	float:left;
}

div#cpu {
	width:50%;
	float:left;
}

div#response {
	width:50%;
	display:block;
	float:left;
}
#response span#response_time {
	font-size: 20px;
}

</style>
</head>

<body>
	<h1 id="hostname"> </h1>
	<div id="main">
		<div class="section">
			<div id="memory"></div>
			<div id="load_avg"></div>
		</div>
		<div class="seciton">
			<div id="cpu"></div>
			<div id="response">
				<b>Last Response Time:</b> <span id="response_time"> -- </span>
			</div>
	</div>
</body>

<script src="/underscore-min.js"></script>
<script src="/jquery-1.7.1.min.js"></script>
<script src="/highcharts.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script>
	Highcharts.theme = { colors: ['#4572A7'] };
</script>
<script>

$(document).ready(function() {
cpu_chart_options = {
      chart: {
         renderTo: 'cpu',
         defaultSeriesType: 'area'
      },
      title: {
         text: 'CPU Utilization'
      },
      xAxis: {
			type: 'datetime',
			tickPixelInterval: 150
      },
      yAxis: {
         title: {
            text: '% Utilization'
         }
		},
      legend: {
         align: 'right',
         x: -100,
         verticalAlign: 'top',
         y: 20,
         floating: true,
         backgroundColor: (Highcharts.theme && Highcharts.theme.legendBackgroundColorSolid) || 'white',
         borderColor: '#CCC',
         borderWidth: 1,
         shadow: false
      },
      tooltip: {
         formatter: function() {
            return '<b>'+ this.x +'</b><br/>'+
                this.series.name +': '+ this.y +'<br/>'+
                'Total: '+ this.point.stackTotal;
         }
      },
      plotOptions: {
         area: {
            stacking: 'percent'
         }
      },
       series: [{
         name: 'User',
         data: []
      }, {
         name: 'System',
         data: []
      }, {
         name: 'Idle',
         data: []
      }]
   };

load_avg_chart_options = {
      chart: {
         renderTo: 'load_avg',
         defaultSeriesType: 'spline'
      },
      title: {
         text: 'Load Average'
      },
		xAxis: {
			type: 'datetime',
			tickPixelInterval:70
		},
		yAxis: {
			title: { text: 'Load' }
		},
      tooltip: {
         formatter: function() {
                   return '<b>'+ this.series.name +'</b><br/>'+
               this.x +': '+ this.y;
         }
      },
      legend: {
         align: 'right',
         x: -100,
         verticalAlign: 'top',
         y: 20,
         floating: true,
         backgroundColor: (Highcharts.theme && Highcharts.theme.legendBackgroundColorSolid) || 'white',
         borderColor: '#CCC',
         borderWidth: 1,
         shadow: false
      },
      series: [
		{
         name: '1 minute',
         data: []
		},
		{
         name: '5 minute',
         data: []
      },
		{
         name: '15 minute',
         data: []
      }]
   };
   
memory_chart_options = {
		chart: {
			renderTo: 'memory',
			plotBackgroundColor: null,
			plotBorderWidth: null,
			plotShadow: false
		},
		title: {
			text: 'Current Server Memory'
		},
		tooltip: {
			formatter: function() {
				return '<b>'+ this.point.name +'</b>: '+ this.percentage +' %';
			}
		},
		plotOptions: {
			pie: {
				allowPointSelect: true,
				cursor: 'pointer',
				dataLabels: {
					enabled: true,
					color: Highcharts.theme.textColor || '#000000',
					connectorColor: Highcharts.theme.textColor || '#000000',
					formatter: function() {
						return '<b>'+ this.point.name +'</b>: '+ this.percentage +' %';
					}
				}
			}
		},
		series: [{
			type: 'pie',
			name: 'Memory',
			data: [
				['Total Memory',100.0]
			]
		}]
	};
}); 	

</script>

<script>

var mem_chart = null;
function update_memory_chart(data) {
	  var gb = data.totalmem/1024/1024/1024;
	  memory_chart_options.title = {text:gb+"GB Memory"};
	  var mem_series = memory_chart_options.series[0];
	  var free = Math.round(100*(data.freemem/data.totalmem));
	  var used = Math.round(100 - free);
	  mem_data = [
			["Free Memory",free],
			["Used Memory",used]
	  ];
	  if(!mem_chart) {
	  		mem_series.data = mem_data;
			mem_chart = new Highcharts.Chart(memory_chart_options);
	  }
	  mem_chart.series[0].setData(mem_data);
}


var load_avg_chart = null;
function update_load_chart(data) {

	  if(!load_avg_chart) {
			var opt_series = load_avg_chart_options.series;
			var start = new Date();
			_.each(opt_series,function(item,idx) {
				for(var i = 0;i<10;i++) {
					item.data.push({x:start.getTime()+i*1000,y:1});
				}
			});
			console.log(opt_series);
			load_avg_chart = new Highcharts.Chart(load_avg_chart_options);
	  }

	  var series = load_avg_chart.series;
	  var measured_at = new Date(data.measured_at).getTime();
	  series[0].addPoint({x:measured_at,y:data.loadavg[0]},false,true);
	  series[1].addPoint({x:measured_at,y:data.loadavg[1]},false,true);
	  series[2].addPoint({x:measured_at,y:data.loadavg[2]},true,true);
}


var cpu_chart = null;
function update_cpu_chart(data) {
	var cpus = data.cpus;
	var xAxis = cpu_chart_options.xAxis;
	xAxis.catagories = []
	cpu_chart_options.subtitle = { text: 'Number of CPUs: '+cpus.length };

	var user = 0,system = 0,idle = 0;
	_.each(cpus,function(element,idx){
		xAxis.catagories.push(element.model);	
		//series.name  /series.data
		// user system idle
		var times = element.times;
		user += times.user;
		system += times.sys;
		idle += times.idle;
	});
	var total = user + system + idle;
	user=100*user/total;
	system=100*system/total;
	idle=100*idle/total;
	
	if(!cpu_chart) {
		var start = new Date(data.measured_at);
		var opt_series = cpu_chart_options.series;
		_.each(opt_series,function(item,idx) {
			for(var i = 0;i<10;i++) {
				item.data.push({x:start.getTime()+i*1000,y:100});
			}
		});
		cpu_chart = new Highcharts.Chart(cpu_chart_options);
	}

	var series = cpu_chart.series;	
	
	var measured_at = new Date(data.measured_at).getTime();
	series[0].addPoint({x:measured_at,y:user},false,true);
	series[1].addPoint({x:measured_at,y:system},false,true);
	series[2].addPoint({x:measured_at,y:idle},true,true);
	
}
</script>
<script>
	var socket = io.connect('http://localhost');
	var points = 0;
   socket.on('REQUEST', function (data) {
		  console.log(data);
	     //socket.emit('my other event', { my: 'data' });
		  var t = data.response_time;
		  var color;
		  if(t < 200) {
		 		color = 'green'; 
		  } else if(t>=200 && t<=500) {
		 		color = 'yellow'; 
		  } else {
		 		color = 'red'; 
		  }

		  $('#response_time').html(data.response_time+' ms').css({color:color});
   });

  socket.on('SYSTEM_INFO', function (data) {
		  console.log(data);
		  points++;
		  var hostname = data.hostname;
		  $('#hostname').html(hostname);
		  update_memory_chart(data);
		  update_load_chart(data);
		  update_cpu_chart(data);
   });

</script>

</html>

